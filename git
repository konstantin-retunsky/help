git config --global core.editor vim - задать редактор по умолчанию для коммита
git config --global user.name "name" - задает имя пользователя для всех проектов
git config --global user.email "email" - задает имя пользователя для всех проектов
git init чтобы создать git репозиторий из этого каталога
git add [filename] добавить файл в репозиторий
git commit (-m "messenger") - доабавить комит
git status - проверка текущее состояние репозитория
git log (--pretty=oneline — однострочный формат) - список произведенных изменений

Вот что я использую для просмотра изменений, сделанных за последнюю неделю. Я добавлю --author=alex, если я хочу увидеть только изменения, которые сделал я.
git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'

Со временем, я решил, что для большей части моей работы мне подходит следующий формат лога.
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short

    --pretty="..." — определяет формат вывода.
    %h — укороченный хэш коммита
    %d — дополнения коммита («головы» веток или теги)
    %ad — дата коммита
    %s — комментарий
    %an — имя автора
    --graph — отображает дерево коммитов в виде ASCII-графика
    --date=short — сохраняет формат даты коротким и симпатичным

https://githowto.com/ru/aliases обая инфа по git

git checkout "название ветки" (master - имя ветки по умолчанию) - выбор нужной ведки
git tag [название тега] - создание тега, что-бы не писать имя ветки по умолчанию
git tag - показать список тегов
git checkout namefile так же удаляет изменения не добавленные в файл

https://githowto.com/ru/undoing_staged_changes - отмена изменений

git checkout filename - преключиться на версию коммита

git revert HEAD - отмена коммита, однако он остается в логе

git reset [--hard указывает, что рабочий каталог должен быть обнавлен в соответствии с новым head ветки] v1 - удаление всех коммитов до коммита с тегом v1
Однако git log --all показывает удаленные ветви, но их не видно в репозитории мастера

git tag (-d nametag - удалить тег навсегда, он исчезает навсегда)

git commit (--amend позволяет изменить старый коммит, без каких либо лишних внесений в логи) -m "Add an author/email comment"

git mv file name namedir - переместить файл в другую дирикторию

git hist --max-count=1 - показывает n-ое количество последних коммитов

git checkout -b style - Примечание: git checkout -b <имяветки> является шорткатом для git branch <имяветки> за которым идет git checkout <имяветки>.

Слияние переносит изменения из двух веток в одну. Давайте вернемся к ветке style и сольем master с style.
git checkout style
git merge master
git hist --all

Решение конфликта при слияние 
Вам необходимо вручную разрешить конфликт. Внесите изменения в lib/hello.html для достижения следующего результата.

https://stackoverflow.com/questions/137102/whats-the-best-visual-merge-tool-for-git - нужные плагины для гита в темрменале

Перебазирование
git checkout style
git rebase master
Слияние VS перебазирование

Конечный результат перебазирования очень похож на результат слияния. Ветка style в настоящее время содержит все свои изменения, а также все изменения ветки master. Однако, дерево коммитов значительно отличается. Дерево коммитов ветки style было переписано таким образом, что ветка master является частью истории коммитов. Это делает цепь коммитов линейной и гораздо более читабельной.

Когда использовать перебазирование, а когда слияние?
Не используйте перебазирование …
    Если ветка является публичной и расшаренной. Переписывание общих веток будет мешать работе других членов команды.
    Когда важна точная история коммитов ветки (так как команда rebase переписывает историю коммитов).
Учитывая приведенные выше рекомендации, я предпочитаю использовать rebase для кратковременных, локальных веток, а слияние для веток в публичном репозитории.

Извлечение изменений
cd ../cloned_hello
git fetch
git hist --all
На данный момент в репозитории есть все коммиты из оригинального репозитория, но они не интегрированы в локальные ветки клонированного репозитория.

В истории выше найдите коммит «Changed README in original repo». Обратите внимание, что коммит включает в себя коммиты «origin/master» и «origin/HEAD».
Теперь давайте посмотрим на коммит «Updated index.html». Вы увидите, что локальная ветка master указывает на этот коммит, а не на новый коммит, который мы только что извлекли.
Выводом является то, что команда «git fetch» будет извлекать новые коммиты из удаленного репозитория, но не будет сливать их с вашими наработками в локальных ветках.

Слияние извлеченных изменений
git merge origin/master

Извлечение и слияние изменений
     Обсуждение
Мы не собираемся опять проходить весь процесс создания нового изменения и его извлечения, но мы хотим, чтобы вы знали, что выполнение:
git pull
действительно эквивалентно двум следующим шагам:
git fetch
git merge origin/master

Небольшое пояснение, что же все-таки означает «чистый репозиторий». Обычный git-репозиторий подразумевает, что вы будете использовать его как рабочую директорию, поэтому вместе с файлами проекта в актуальной версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории .git. В удаленных репозиториях нет смысла хранить рабочие файлы на диске (как это делается в рабочих копиях), а все что им действительно нужно — это дельты изменений и другие бинарные данные репозитория. Вот это и есть «чистый репозиторий».
cd ..

ls hello.git
Как правило, репозитории, оканчивающиеся на «.git» являются чистыми репозиториями. Мы видим, что в репозитории hello.git нет рабочего каталога. По сути, это есть не что иное, как каталог .git нечистого репозитория

Добавление удаленного репозитория
cd hello
git remote add shared ../hello.git

curl -u 'USER' https://api.github.com/user/repos -d '{"name":"REPO"}' - создание удаленно репозиторий (User - никнейм на гитхабе) (REPO - название репозитория)

Перед этим нужно быть в ветке мастера, и закомитить файлы

git remote add origin git@github.com:konstantin-retunsky/help.git - подключение к репозиторию, когда подключен ключ ssh, где help.git - название дерриктории, .git - обязательная приставка 
После чего можно спокойно пушить

Пуш осуществляется следующим образом - git push -u origin master
